"use strict";function getTimedResolvingPromise(e,i){return new Promise(o=>{setTimeout(()=>o(i),e)})}function getTimedRejectingPromise(e,i){return new Promise((o,s)=>{setTimeout(()=>o(i),e)})}Object.defineProperty(exports,"__esModule",{value:!0}),require("../implementation"),test("The first resolving Promise should be acted upon.",()=>{let e=[getTimedResolvingPromise(20,"yes"),getTimedResolvingPromise(50,"nope"),getTimedResolvingPromise(65,"nuh-uh")];Promise.any(e).then(e=>{expect(e).toBe("yes")})}),test("Rejecting Promises should not effect the acted-upon value so long as some Promise resolves.",()=>{let e=[getTimedRejectingPromise(5,"ignore me"),getTimedResolvingPromise(50,"yes"),getTimedResolvingPromise(85,"nuh-uh")];Promise.any(e).then(e=>{expect(e).toBe("yes")})}),test("If all Promises reject, Promise.any should reject.",()=>{let e=[getTimedRejectingPromise(5,"ignore me"),getTimedResolvingPromise(50,"yes"),getTimedResolvingPromise(85,"nuh-uh")];Promise.any(e).then(e=>{fail("Promise.any resolved even though none of it's provided Promises resolved.")})}),test("Given some non-Promise items, Promise.any should return the first of these.",()=>{let e=[getTimedRejectingPromise(5,"ignore me"),getTimedResolvingPromise(50,"yes"),"Hello there!",getTimedResolvingPromise(85,"nuh-uh")];Promise.any(e).then(e=>{expect(e).toBe("Hello there!")})});
//# sourceMappingURL=promise-any.test.js.map
